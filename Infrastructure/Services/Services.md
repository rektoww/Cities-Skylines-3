StaticMapProvider.cs — документация

Этот документ объясняет назначение и устройство класса StaticMapProvider, который собирает фиксированную карту для приложения (без случайной генерации) из двух строковых масок: рельефа и ресурсов.

Назначение

StaticMapProvider создаёт и возвращает экземпляр GameMap, заполняя каждую клетку (Tile) типом рельефа (Terrain) и ресурсами (Resources) согласно двум «текстовым маскам». Это удобно для лабораторной работы: карта детерминирована, легко редактируется прямо в коде и всегда воспроизводима.

Краткая схема работы:

Внутри Build() объявлены два массива строк одинаковой высоты:

terrainRows — рельеф.

resourceRows — ресурсы.

Проверяется, что высота обеих масок совпадает.

Вычисляется ширина карты как максимальная длина строки среди обеих масок (защита от «коротких» строк).

Создаётся GameMap(width, height), внутри которого инициализировано Tile[,].

Для каждой клетки (x, y):

читается символ рельефа (за пределами строки подставляется '.' = равнина);

читается символ ресурса (за пределами строки — «нет ресурса»);

назначаются Tile.Terrain и, при необходимости, добавляется NaturalResource в Tile.Resources.

Готовая карта возвращается вызывающему коду.

Легенда масок

Рельеф (terrainRows):

~ — Water (вода)

^ — Mountain (гора)

# — Mountain (скальное плато, трактуем как гору)

. — Plain (равнина)

любой другой символ — по умолчанию Plain

Ресурсы (resourceRows):

I — Iron (железо)

O — Oil (нефть)

G — Gas (газ)

любой другой символ — «ресурса нет»

Количество ресурсов на клетке в текущей реализации фиксировано: Amount = 200.

Ключевые зависимости

Модели:

GameMap (содержит Width, Height и двумерный массив Tiles типа Tile[,])

Tile (координаты X, Y, Terrain, список Resources)

NaturalResource (поля Type, Amount)

Перечисления:

TerrainType (Water, Mountain, Plain, …)

ResourceType (Iron, Oil, Gas, …)

Важные детали реализации

Индексация тайлов: у карты — двумерный массив. Доступ к клетке — map.Tiles[x, y], а не map.Tiles[x][y].

Защита от «коротких» строк: если длина строки меньше ширины карты, недостающие символы трактуются как равнина без ресурсов — это делает маски менее хрупкими.

Детерминизм: отсутствие любой рандомизации гарантирует одинаковую карту при каждом запуске.

Как редактировать карту

Откройте StaticMapProvider.Build().

Изменяйте terrainRows и resourceRows:

добавляйте/удаляйте символы в строках;

следите, чтобы количество строк у обеих масок совпадало.

Сохраните файл — карта сразу изменится при следующем запуске.

Совет: старайтесь выравнивать длины строк, чтобы визуально понимать, какие символы соответствуют друг другу.

Производительность и масштаб

Текущая реализация проходит по всем клеткам один раз: сложность O(width * height).

Подходит для учебных размеров карт (десятки × десятки клеток). Для больших карт (>1000×1000) стоит задуматься о потоковой загрузке/визуализационной виртуализации, но в данной работе это не требуется.

Расширение функциональности

Новые типы рельефа/ресурсов
Добавьте символ в легенду и обновите соответствующие switch:

tile.Terrain = t switch
{
    'F' => TerrainType.Forest,
    _   => ...
};


Другая «маска» ресурсов
Можно использовать несколько ресурсов на клетку, назначая символам разные типы или объёмы.

Извлечение масок из файла
Вынесите terrainRows/resourceRows в JSON/текст и читайте с диска (понадобится валидация и обработка ошибок).

Интеграция с UI

MainViewModel.LoadStatic() вызывает StaticMapProvider.Build() и присваивает результат в CurrentMap.

Для отрисовки используется TilesFlat (плоское перечисление Tile), а UniformGrid.Columns берёт CurrentMap.Width.

Цвет клетки выбирается триггером в XAML по Tile.Terrain.
Информация о ресурсах — через ToolTip и диалог ShowTileInfoCommand.

Минимальный пример использования
/// <summary>Команда: загрузить статичную карту.</summary>
[RelayCommand]
private void LoadStatic()
{
    // Создаём фиксированную карту и публикуем в VM
    CurrentMap = StaticMapProvider.Build(); // обновит UI через PropertyChanged
}